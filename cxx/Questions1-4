1: class & struct

Create a Stock class to represent a simple stock abstraction holding the following information:
Ticker Symbol
Exchange
Company Name
Price
Provide a setup method for Ticker, Exchange, Name and Price so that they have an initial value. Provide a method setPrice to update a stock object's price each time the market changes, and display to show the current state of the stock (essentially all the information it contains). Ensure that your class makes proper use of access regions to control the visibility of information. We suggest you make use of std::string and double for the members of the class. Create a program that demonstrates the behaviour of your class library.
Change the Stock class so that each stock object is associated with a series of prices, one for each time a price "tick" is received. Create a new struct for price ticks (Tick) that models the price and the time of each tick. Extend setPrice in the Stock class to receive time information in addition to the price, and to create a Tick object each time it is called. Store Tick objects inside each Stock object using a simple fixed array of Tick* pointers (or an std::list if you are familiar). The next exercise will build a better structure to hold them.
Extend the display method in Stock to show the price range for a given day, lowest to highest, in addition to the closing price. Create a new method showCurve that displays a set of prices for a given period.
To manage an arbitrarily sized set of Tick objects associated with each Stock object a more intelligent structure needs to be created. Build a single (or double) linked-list structure to manage the ticks, and install and test this within your Stock class.
The following code sample provides the skeleton of the classes necesary for a simple list and an example of how it might be used. Copy the code, complete the implementations (including friendship declarations), and integrate into the Stock example.
namespace my
{
    class Node;
    class Iter;

    class List
    {
        Node *head;
    public:
        void setup();
        Node *first();
        void add (Tick&);
    };

    class Node
    {
        Tick *elem;
        Node *next;
    };

    class Iter
    {
        List *l;
        Node *cur;
    public:
        void setup(List& li)
        {
            l = &li;
            cur = l->first();
        }
        bool valid()
        {
            return cur != 0;
        }
        Tick *elem()
        {
            return cur->elem;
        }
        void next()
        {
            if (valid())
                cur = cur->next;
        }
        void reset()
        {
            cur = l->first();
        }
    };
}
A simple test program to demonstrate the basic behaviour of the list:
int foo()
{
    using namespace my;

    List l;
    l.setup();

    Tick t1, t2;

    l.add (t1);
    l.add (t2);

    Iter i;
    i.setup (l);

    while (i.valid())
    {
        Tick *p = i.elem();
        // do stuff with p
        i.next();
    }
}

2: Constructors & Destructors

Update the Stock class developed in exercise 10 to replace the setup method with a constructor. Create both automatic and dynamic instances of Stock and use the display method to verify that objects are properly constructed.
Stock apple("AAPL", "NASDAQ", "Apple Inc.", 351.56);
Stock ibm("IBM", "NYSE", "International Business Machines Corp.", 161.55);
Stock *morgan = new Stock("MS", "NYSE", "Morgan Stanley", 29.2);
Add appropriate constructor functions throughout the Stock exercise to replace setup methods used in the Tick class and list implementation. Verify that the program is still correct
Make the display method in Stock const, and examine the interfaces of all methods in all of the classes and use const wherever appropriate. Ensure you code still compiles!
Add appropriate destructor functions throughout the Stock exercise to ensure that all objects are properly cleaned up. Pay particular attention to the list of Tick objects, as when the associated Stock object dies, the entire list of its Ticks must also be destroyed.
Place std::cout statements in all of the constructor and destructor functions to monitor that a) the expected number of objects instances are created during program execution, and b) that all such instances are subsequently destroyed by program exit.

3: Object Modeling

Model a computer Monitor as the composition of the objects of Panel and Case.
	Monitor   Attribute    brand, Panel, Case
	          Methods      constructor, destructor, display

	Panel     Attribute    size, type
	          Methods      constructor, display

	Case      Attributes   size
	          Methods      constructor
All of the attributes of each class must be initialised when objects are instantiated. Note that the size of the case is 1.2 times that of the panel.
Panel type is simply an enumeration of LED, LCD and PLASMA. The implementation of display in Monitor is a call to display in its Panel object. The implementation of display in the Panel object, is simply a call to std::cout.
Define all of the classes and write a simple application program to make an instance of Monitor and call the display method.
Define a System class and a Keyboard class such that an instance of Keyboard can be associated with an instance of System, and an instance of System can be associated with up to 4 Monitors. Define methods such that typing on the keyboard causes input to be generated for the System, and data to be displayed on the Monitors.
Write a simple application to create objects of your classes, wire them appropriately and execute the typing scenario described.
Who holds custody of the various parts of the computer?

4: Class Data & Functions

Study the code below
class A {
    static int val;
    const int max;
    int x;
public:
    A(int x_init, int max_init) {}
    void display() const {}
};

int main()
{
    A a(10, 100);
}
Now add code to:
properly initialise val to 30, x to 10 and max to 100
display all the data members
return the value in val with an accessor function
A useful design pattern often implemented in C++ is a singleton. The idea behind a singleton is that only one instance of the singleton class can be instantiated.
The purpose of this exercise is to make the following class into a singleton. This will require the use of both static member data and static member functions.
class Data {
    int i;
public:
    int get() const;
    void set(int);
};	
To convert this into a singleton, the following must be done (but think about it).
Make the constructor private to stop client code being able to make instances in the normal way.
Provide a public static function instance that returns the instance---if one has already been made. It must make the instance if there is none.
Store the address of the instance (once created) in a static data member, so it can be used with subsequent calls to instance.
Example usage of singleton Data:
Data *d = Data::instance();	// makes & returns instance
d->set(5);
std::cout << d->get() << std::endl;
	
Data *p = Data::instance();	// gets hold of same instance
std::cout << p->get() << std::endl;

// Data d;			// illegal
The following program has a memory fault, though it will likely compile and execute without any obvious issue. (The g++ option -fno-elide-constructors may make the fault more obvious.) Identify the problem with the code. Prove your assessment by inserting std::cout statements in the constructor and destructor. Change the class definition to resolve the issue.
class A
{
    char *cp;
    double &dr;
public:
    A(char c, double &r)
    : dr(r)
    {
        cp = new char (c);
    }
    char get() const
    {
        return *cp;
    }
    ~A()
    {
        delete cp;
    }
};

A foo(double& d)
{
    A a('c', d);
    return a;
}

int main()
{
    double d=3.14;
    foo(d).get();
}

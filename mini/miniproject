Mini-Project

You are required to build a menu driven suite of administrative tools using shell programming, awk, and the various utility programs and filters that are available in Unix.
The exercise should be solved incrementally so that you slowly enhance the toolkit. Do not worry if you cannot complete all of the stages; focus on making the stages that you complete as well constructed as possible.
Programming Tips
Structure your code neatly so that it can be easily read by others. Make use of indentation so that the body of a 'loop' or 'if test' clearly stands out. Also choose variable names that are meaningful and add useful comments where necessary.
Test for errors. Make sure that the exit status of each utility program that you use is as anticipated. Make sure that files exist before you try to operate on them, and that you have necessary permissions. When an error occurs inform the user gracefully (perhaps by prompting for an alternate file name), or die gracefully with an error message that explains why.
Project
Write a program that lists the processes owned by a specified user. If no user name is given a usage error message should be written. The program should display the PID, PPID and command name of the process.
$ proc evad
    20402 20401 -ksh
    24688 24097 vi afile
    24097 24096 more
    24699 24133 proc evad
Write a program to allow a user to kill one of their processes by name. The unix 'kill' command expects a PID, but your utility should work by command name. When invoked, if a suitably named command does not exist, or if two or more commands with the same name exist, then an error should be raised. Also, your program should verify that the process has been killed before writing a confirmation message.
$ die more
    more (24097) has now been killed
Extend the above program to kill any process by name. If the process is not owned by you, then prompt for a password, ksu to the user, and then kill the process---of course, provided there is only one instance of the command!
Extend the above program to allow multiple instances of the same command to be selectively deleted. When multiple instances are found, display a list showing owner, PID, PPID, and command name with all of the command line arguments. For each item in the list display a number, and then allow the user to either type a number to indicate which process should be deleted, or to type * to indicate that all processes should be deleted.
$ die more
    1)    evad   20402 20401 more /etc/passwd
    2)   evad   24688 24097 more afile
    3)   jane   24097 24096 more
    4)   george 24699 24133 more name.C
Enter number: 1
evad (20402) more /etc/passwd has now been killed

$ die more<br>
    1)    evad   20402 20401 more /etc/passwd
    2)   evad   24688 24097 more afile
    3)   jane   24097 24096 more
    4)   george 24699 24133 more name.C
Enter number: 3
Enter password for jane:
jane (24097) more has now been killed

$ die more
    1)    evad   20402 20401 more /etc/passwd
    2)   evad   24688 24097 more afile
    3)   jane   24097 24096 more
    4)   george 24699 24133 more name.C
Enter number: *
Enter password for jane: 
Enter password for george: 
Incorrect password. Enter password for george:
evad (20402) more /etc/passwd has now been killed
evad (24688) more afile has now been killed
jane (24097) more  has now been killed
george (24699) 24133 more name.C has now been killed
Provide a die command that allows processes owned by specified users on specified hosts to be killed either by name or PID. Provide the usual error handling and verification.
$ die sait401 evad netscape
evad (24097) netscape on sait401 has now been killed
Provide a utility to display a directory as a tree. Provide an absolute or relative directory as an argument. The command should then draw the sub, sub-sub (etc) directories in a tree like fashion. (Below is a simple example, but there are nicer ways to lay it out.)
$ tree .
.
+ etc
 + default
  + settings
  + users
 + usr
  + share
   + man
  + bin
  + man
  + lib
  + include
Explore the use of the tput command. This allows you to address portions of your terminal, ie, write to arbitrary positions on the screen. Using the sleep command to pause momentarily, write a program that bounces a cursor from the top of the screen to the bottom, and then back up to the top.
Using the techniques explored in 7, write a utility which continually displays the processes owned by a specified user. As new processes are added and old ones die, the screen should automatically update itself to show the current state. Your output should at least include PID, PPID, Command name.
Add CPU and memory utilisation to the output of the utility in 8. Allow the user to specify whether the output should be sorted by CPU utilisation, memory utilisation, PID, PPID or command name; and whether to sort in an ascending or descending order.
Add the techniques for drawing a tree from question 6 into the command devised in 9. Continually display your process table in a tree form, where the tree is based on the parent child relationship between the processes.
When a new process is created it should dynamically appear in the list and be placed in the right position to reflect its parenthood.
Useful Hints
Check out the man page for ps to get the most useful output
To create lots of processes to play with use the sleep command
